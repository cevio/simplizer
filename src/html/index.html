<html lang="zh-CN">

<head>
  <meta charset="utf-8" />
  <meta http-equiv="cache-control" content="max-age=0" />
  <meta http-equiv="cache-control" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
  <meta http-equiv="pragma" content="no-cache" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="format-detection" content="telephone=no" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <title>App name</title>
  <link href="http://cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.css" rel="stylesheet">
</head>

<body>

  <template name="a">

    <div class="web-container">
      <div class="web-row">
        <div class="web-col-33 tc">asasas</div>
        <div class="web-col-66 tc">wadawdwd</div>
      </div>
    </div>

      <div class="readme-body web-container"><h1 id="webservice">webservice</h1>
      <p>webservice 是一套单页面级的路由框架，包含了<code>soyie</code> <code>soyie-http-router</code>等框架或组件，能够实现复杂路由功能，类似于nodejs的<code>express</code>框架。它的优点在于我们可以处理复杂逻辑的页面路由，通过自定义路由回调，轻松实现页面逻辑。</p>
      <h1 id="install">install</h1>
      <blockquote>
      <p>nap install --save webservicer</p>
      </blockquote>
      <div style="height:300px; width:100%;" v-on:click="click"><middle style="text-align:center">test</middle></div>
      <h1 id="usage">usage</h1>
      <pre><code class="lang-javascript hljs"><span class="hljs-keyword">var</span> soyie = <span class="hljs-built_in">require</span>(<span class="hljs-string">'soyie'</span>);
      <span class="hljs-keyword">var</span> webservice = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webservicer'</span>);
      <span class="hljs-keyword">var</span> app = webview(soyie);
      app.active(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>{
          res.render(<span class="hljs-string">'home'</span>);
      });
      soyie.ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
          app.listen(<span class="hljs-string">'envirs-cms'</span>);
      });
      </code></pre>
      <h1 id="app">app</h1>
      <p>app 是一个webservice初始化的实例对象，可以认为是一个HTTP服务引擎。</p>
      <h2 id="app-api">app api</h2>
      </div>


        <div v-for="item in test" transition="bounceUp" stagger='100'>
            <div>{{item}}</div>
        </div>

    <!-- <as>wwww</as> -->
  </template>
  <template name="b">
      <div class="content api with-sidebar web-container" id="scroll_1456415628788"><h1 id="summary">Summary</h1><p>NodeAsp是一套Classic ASP框架，借鉴了NodeJS的模块化思想，让您可以使用全新的理念愉快地书写ASP程序。</p><p>NodeAsp使用遵循CommonJS规范的require，完全兼容NodeJS模块加载方式，让您可以直接使用NodeJS 50%以上的模块。一切不关乎NodeJS运行环境和ES5-ES6特有对象的模块都能直接使用。如此庞大的模块资源库，这在以往任何ASP框架下都是没有的。</p><p>NodeAsp是ASP领域独树一帜的创新性框架，她的出现改变了传统的ASP编写模式，让您只需要会js就可以同时完成前后端开发，并免除了部署NodeJS服务器的繁琐过程。</p><p>NodeAsp作为ASP领域的终结者，来了。</p><h2 id="nodeasp-runtime">NodeAsp Runtime</h2><p>这个框架仅限在WIN平台IIS上运行。通常普通的ASP虚拟主机即可运行本框架。</p><h2 id="start-to-use-nodeasp">Start to use nodeAsp</h2><blockquote><p>第一步：下载并解压 <a href="http://nodeasp.com/downloads/nodeasp.zip">NodeAsp</a>。</p></blockquote><p>如果您已经安装了<code>nap-cli</code>，那么您可以通过使用命令 <code>nap init</code> 来初始化安装nodeAsp.</p><blockquote><p>第二步：引用 NodeAsp。</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="code"><pre>&lt;!--<span class="comment">#include file="NodeAsp.min.asp" --&gt;</span></pre></td></tr></tbody></table></figure><blockquote><p>第三步：使用NodeAsp。</p></blockquote><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre>&lt;%
      <span class="keyword">var</span> version = process.version;
      Response.Write(version);
  %&gt;</pre></td></tr></tbody></table></figure><h1 id="gobal-object">Gobal-Object</h1><p>这些对象在所有模块中都是可用的。有些对象实际上并非在全局作用域内，而仅仅是在模块作用域内——这种情况在以下文档中会特别指出。</p><h2 id="global">global</h2><p>在浏览器中，顶级作用域就是全局作用域。这就是说，在浏览器中，如果当前是在全局作用域内，var something将会声明一个全局变量。在NodeAsp中则不同。顶级作用域并非全局作用域，在NodeAsp模块里的<code>var something</code>只属于那个模块。</p><h2 id="process">process</h2><p>在NodeAsp中，process存在的主要目的是为了兼容某些NodeJS模块，通常不会使用得到。</p><h2 id="console">console</h2><p>用于打印标准输出和标准错误。见<a href="#console-api">控制台</a>章节。</p><h2 id="buffer">Buffer</h2><p>用于处理二进制数据。在ASP环境中，处理二进制通常使用Adodb.Stream，所以我们目前不支持Buffer。</p><h2 id="require">require</h2><p>引入模块。与NodeJS有点不一样的是，因为IIS只能直接执行ASP文件而非JS文件，所以require也可以用于在ASP代码中require一个模块。</p><p>见<a href="#modules">模块</a>章节。</p><h2 id="__filename">__filename</h2><p>当前所执行代码文件的文件路径。这是该代码文件经过解析后的绝对路径。</p><p>例如：执行 <code>C:\websites\nodeasp\index.asp</code></p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="comment">// module.js</span>
  Response.Write(__filename);
  <span class="comment">// C:\websites\nodeasp\module.js</span>

  <span class="comment">// index.asp</span>
  <span class="keyword">require</span>(<span class="string">'./module'</span>);
  Response.Write(__filename);
  <span class="comment">// C:\websites\nodeasp\index.asp</span></pre></td></tr></tbody></table></figure><h2 id="__dirname">__dirname</h2><p>当前执行脚本所在目录的目录名。</p><h2 id="module">module</h2><p>当前模块的引用。特别地，module.exports和exports指向同一个对象。module实际上并非全局的而是各个模块本地的。</p><p>见<a href="#modules">模块</a>章节。</p><h2 id="exports">exports</h2><p>module.exports对象的引用，该对象被当前模块的所有实例所共享，通过require()可访问该对象。 何时使用exports以及何时使用module.exports的详情可参见模块系统文档。 exports实际上并非全局的而是各个模块本地的。</p><p>见<a href="#modules">模块</a>章节。</p><h2 id="timer">timer</h2><p>定时器函数一共包括以下四个。由于ASP是单线程的，所以以下函数实际上是不兼容的。</p><ul><li>setTimeout(cb, ms)</li><li>clearTimeout(t)</li><li>setInterval(cb, ms)</li><li>clearInterval(t)</li></ul><h1 id="console-api">console api</h1><p>类似NodeJS/Chrome浏览器的命令行调试模块。请前往下载<a href="http://nodeasp.com/downloads/console.zip">控制台调试程序</a>。</p><blockquote><p>注意：需要.NET 4.0支持才能运行。</p></blockquote><ul><li><p>注册COM组件</p><p>以管理员权限打开CMD，使用REGASM命令注册 Terminal.dll，其中REGASM位于<code>C:\Windows\Microsoft.NET\Framework\v4.0.30319</code>(具体位置与版本号有关)。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="comment">// 在命令行执行以下命令，记住需要管理员权限</span>
  C:\Windows\Microsoft.NET\Framework\v4.<span class="number">0.30319</span>\REGASM
  D:\component\Terminal.dll /codebase</pre></td></tr></tbody></table></figure></li><li><p>修改注册表，解决 <code>ASP 0177 : 8000ffff</code> 错误</p><p>对于32位系统，找到如下注册表位置：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\MAIN\FeatureControl\FEATURE_IGNORE_ZONES_INITIALIZATION_FAILURE_KB945701</pre></td></tr></tbody></table></figure><p>对于64位系统，找到如下注册表位置：</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre>HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Internet Explorer\MAIN\FeatureControl\FEATURE_IGNORE_ZONES_INITIALIZATION_FAILURE_KB945701</pre></td></tr></tbody></table></figure><p>选择或者新建项 <code>FEATURE_IGNORE_ZONES_INITIALIZATION_FAILURE_KB945701</code>，然后新建DWORD值：</p><p>名称：<code>w3wp.exe</code> 值：<code>1</code></p></li><li><p>启动Console</p><p>双击 <code>Console.exe</code>，打开NodeAsp调试命令行工具。</p></li><li><p>调试</p><p>在index.asp中输入以下代码，然后运行index.asp。接下来，你就可以在 <code>Console.exe</code>中看到结果了。</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="comment">// index.asp</span>
  <span class="keyword">var</span> a = {name: <span class="string">"nodeasp"</span>, value: <span class="keyword">true</span>}
  <span class="comment">// 在console中将输出</span>
  <span class="comment">//{</span>
  <span class="comment">//    name: "nodeasp",</span>
  <span class="comment">//    value: true</span>
  <span class="comment">//}</span></pre></td></tr></tbody></table></figure></li></ul><h2 id="console-log-data-">console.log([data][, ...])</h2><p>向Console输出一个或多个参数的结果，使用默认颜色。</p><h2 id="console-info-data-">console.info([data][, ...])</h2><p>同console.log，使用绿色。</p><h2 id="console-warn-data-">console.warn([data][, ...])</h2><p>同console.log，使用黄色。</p><h2 id="console-error-data-">console.error([data][, ...])</h2><p>同console.log，使用红色。</p><h2 id="console-time-label-">console.time(label)</h2><p>使用label指定名称，开始一个计时器，用于计算操作所需要花费的时间。</p><h2 id="console-timeend-label-">console.timeEnd(label)</h2><p>输出某项操作所需要消耗的时间。</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre>console.time(<span class="string">'100-elements'</span>);
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {
      ;
  }
  console.timeEnd(<span class="string">'100-elements'</span>);
  <span class="comment">// prints 100-elements: 262ms</span></pre></td></tr></tbody></table></figure><h1 id="modules">modules</h1><p>NodeAsp有一个跟NodeJS几乎一致的模块加载系统，这样可以保证NodeAsp可以直接使用大量NodeJS的模块。</p><p>NodeAsp的核心几乎不包含任何开发网站需要功能，所有功能都是通过模块来扩展的。可以通过NodeAsp的模块中心或者<code>npmjs</code>来寻找您所需要的功能模块。</p><p>在NodeAsp中，文件和模块是一一对应的。下面是示例<code>foo.js</code>加载同一目录下的<code>circle.js</code>。</p><p>foo.js的内容</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="keyword">var</span> circle = <span class="keyword">require</span>(<span class="string">'./circle.js'</span>);
  console.log( <span class="string">'The area of a circle of radius 4 is '</span> + circle.area(<span class="number">4</span>) );</pre></td></tr></tbody></table></figure><p>circle.js的内容:</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="keyword">var</span> PI = Math.PI;
  exports.area = <span class="keyword">function</span> (r) {
      <span class="keyword">return</span> PI * r * r;
  };
  exports.circumference = <span class="keyword">function</span> (r) {
      <span class="keyword">return</span> <span class="number">2</span> * PI * r;
  };</pre></td></tr></tbody></table></figure><p>circle.js模块输出了area()和circumference()两个函数。要输出某个对象，把它加到exports这个特殊对象下即可。</p><p>注意，exports是module.exports的一个引用，只是为了用起来方便。当你想输出的是例如构造函数这样的单个项目，那么需要使用module.exports。</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="comment">// 正确输出构造函数</span>
  module.exports = MyConstructor;</pre></td></tr></tbody></table></figure><p>模块内的本地变量是私有的。在这个例子中，PI这个变量就是circle.js私有的。</p><h2 id="repeat-cycle">repeat cycle</h2><p>考虑这样一种情形:</p><p>a.js</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre>console.log(<span class="string">'a starting'</span>);
  exports.done = <span class="keyword">false</span>;
  <span class="keyword">var</span> b = <span class="keyword">require</span>(<span class="string">'./b.js'</span>);
  console.log(<span class="string">'in a, b.done = %j'</span>, b.done);
  exports.done = <span class="keyword">true</span>;
  console.log(<span class="string">'a done'</span>);</pre></td></tr></tbody></table></figure><p>b.js</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre>console.log(<span class="string">'b starting'</span>);
  exports.done = <span class="keyword">false</span>;
  <span class="keyword">var</span> a = <span class="keyword">require</span>(<span class="string">'./a.js'</span>);
  console.log(<span class="string">'in b, a.done = %j'</span>, a.done);
  exports.done = <span class="keyword">true</span>;
  console.log(<span class="string">'b done'</span>);</pre></td></tr></tbody></table></figure><p>main.js</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre>console.log(<span class="string">'main starting'</span>);
  <span class="keyword">var</span> a = <span class="keyword">require</span>(<span class="string">'./a.js'</span>);
  <span class="keyword">var</span> b = <span class="keyword">require</span>(<span class="string">'./b.js'</span>);
  console.log(<span class="string">'in main, a.done=%j, b.done=%j'</span>, a.done, b.done);</pre></td></tr></tbody></table></figure><p>首先main.js加载a.js,接着a.js又去加载b.js。这时，b.js会尝试去加载a.js。为了防止无限的循环，a.js会返回一个unfinished copy给b.js。然后b.js就会停止加载，并将其exports对象返回给a.js模块。</p><p>这样main.js就把这两个模块都加载完成了。这段程序的输出如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre>main starting
  a starting
  b starting
  in b, a.done = <span class="keyword">false</span>
  b done
  in a, b.done = <span class="keyword">true</span>
  a done
  in main, a.done=<span class="keyword">true</span>, b.done=<span class="keyword">true</span></pre></td></tr></tbody></table></figure><p>跟NodeJS一样，通常循环依赖模块并不会导致死循环，但是如果此时直接在模块加载时执行其它模块的方法，会提示找不到对应的方法，所以应该避开这种情况。</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="comment">// a.js</span>
  <span class="keyword">var</span> b = <span class="keyword">require</span>(<span class="string">'./b.js'</span>);
      exports.add = <span class="keyword">function</span>(m, n) {
      console.info(m + n);
  };
  <span class="comment">// b.js</span>
  <span class="keyword">var</span> a = <span class="keyword">require</span>(<span class="string">'./a'</span>);
  <span class="keyword">var</span> m = <span class="number">101</span>, n = <span class="number">102</span>;
  exports.result = <span class="keyword">function</span>() {
      a.add(m, n);        <span class="comment">// 此处没有问题</span>
  };
  a.add(m, n);            <span class="comment">// 此处会报错，找不到a.add方法</span></pre></td></tr></tbody></table></figure><h2 id="file-module">file module</h2><p>如果按文件名没有查找到，那么NodeAsp会添加 .js和 .json后缀名，再尝试加载。</p><p><code>.js</code>会被解析为Javascript纯文本文件，<code>.json</code>会被解析为JSON格式的纯文本文件。</p><p>模块以<code>/</code>为前缀，则表示绝对路径。例如，<code>require('/home/marco/foo.js')</code> ，加载的是<code>/home/marco/foo.js</code>这个文件。</p><p>模块以<code>./</code>为前缀，则路径是相对于调用<code>require()</code>的文件。 也就是说，<code>circle.js</code>必须和<code>foo.js</code>在同一目录下，<code>require('./circle')</code>才能找到。</p><p>当没有以<code>/</code>或者<code>./</code>来指向一个文件时，这个模块是从<code>node_modules</code>文件夹加载的。</p><p>如果指定的路径不存在，<code>require()</code>会抛出一个错误。</p><h2 id="load-from-node_modules">load from node_modules</h2><p>如果require()中的模块名不是一个本地模块，也没有以<code>/</code>, <code>../</code>, 或是 <code>./</code>开头，那么node会从当前模块的父目录开始，尝试在它的/node_modules文件夹里加载相应模块。</p><p>如果没有找到，那么就再向上移动到父目录，直到到达顶层目录位置。</p><p>例如，如果位于<code>/home/ry/projects/foo.js</code>的文件调用了<code>require('bar.js')</code>，那么node查找的位置依次为：</p><ul><li>/home/ry/projects/node_modules/bar.js</li><li>/home/ry/node_modules/bar.js</li><li>/home/node_modules/bar.js</li><li>/node_modules/bar.js</li></ul><p>这就要求程序员应尽量把依赖放在就近的位置，以防崩溃。</p><h2 id="module-package">module package</h2><p>可以把程序和库放到一个单独的文件夹里，并提供单一入口来指向它。有三种方法，使一个文件夹可以作为require()的参数来加载。</p><p>首先是在文件夹的根目录创建一个叫做package.json的文件，它需要指定一个main模块。下面是一个package.json文件的示例。</p><figure class="highlight json"><table><tbody><tr><td class="code"><pre>{
      "name" : "some-library",
      "main" : "./lib/some-library.js"
  }</pre></td></tr></tbody></table></figure><p>示例中这个文件，如果是放在<code>./some-library</code>目录下面，那么<code>require('./some-library')</code>就将会去加载<code>./some-library/lib/some-library.js</code>。</p><p>如果目录里没有<code>package.json</code>这个文件，那么node就会尝试去加载这个路径下的<code>index.js</code>。</p><h2 id="cache">cache</h2><p>模块在第一次加载后会被缓存。这意味着（类似其他缓存）每次调用<code>require('foo')</code>的时候都会返回同一个对象，当然，必须是每次都解析到同一个文件。</p><p>多次调用 <code>require(foo)</code> 未必会导致模块中的代码执行多次. 这是一个重要的功能. 借助这个功能, 可以返回部分完成的对象; 这样, 传递依赖也能被加载, 即使它们可能导致循环依赖。</p><p>如果你希望一个模块多次执行，那么就输出一个函数，然后调用这个函数。</p><p>模块的缓存是依赖于解析后的文件名。由于随着调用的位置不同，可能解析到不同的文件（比如需从node_modules文件夹加载的情况），所以，如果解析到其他文件时，就不能保证<code>require('foo')</code>总是会返回确切的同一对象。</p><h2 id="module-object">module object</h2><p>在每一个模块中，变量 module 是一个代表当前模块的对象的引用。 特别地，module.exports 可以通过全局模块对象 exports 获取到。 module 不是事实上的全局对象，而更像是每个模块内部的。</p><h3 id="module-exports">module.exports</h3><p><code>module.exports</code>对象是通过模块系统产生的。因此，只需要将要导出的对象赋值给<code>module.exports</code>。例如，我们也可以使用下面的方法来写circle.js，这是完全等效的。</p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="comment">// circle.js</span>
  <span class="keyword">var</span> PI = Math.PI;
  <span class="keyword">var</span> circle = {};
  circle.area = <span class="keyword">function</span> (r) {
      <span class="keyword">return</span> PI * r * r;
  };
  circle.circumference = <span class="keyword">function</span> (r) {
      <span class="keyword">return</span> <span class="number">2</span> * PI * r;
  };
  module.exports = circle;</pre></td></tr></tbody></table></figure><h3 id="module-id">module.id</h3><p>用于区别模块的标识符。通常是完全解析后的文件名。</p><h3 id="module-filename">module.filename</h3><p>模块完全解析后的文件名。</p><h3 id="module-parent">module.parent</h3><p>引入这个模块的模块。</p><h2 id="search-process">search process</h2><p>当使用require()引用一个模块时，是按照如下流程根据表达式来查找目标模块的。</p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="keyword">require</span>(X) from module at path Y
  <span class="number">1</span>. <span class="keyword">If</span> X begins with <span class="string">'./'</span> <span class="keyword">or</span> <span class="string">'/'</span> <span class="keyword">or</span> <span class="string">'../'</span>
  a. LOAD_AS_FILE(Y + X)
  b. LOAD_AS_DIRECTORY(Y + X)
  <span class="number">2</span>. LOAD_NODE_MODULES(X, dirname(Y))
  <span class="number">3</span>. <span class="keyword">THROW</span> <span class="string">"not found"</span>

  LOAD_AS_FILE(X)
  <span class="number">1</span>. <span class="keyword">If</span> X is a file, load X <span class="keyword">as</span> JavaScript text.  STOP
  <span class="number">2</span>. <span class="keyword">If</span> X.js is a file, load X.js <span class="keyword">as</span> JavaScript text.  STOP
  <span class="number">3</span>. <span class="keyword">If</span> X.json is a file, parse X.json to a JavaScript Object.  STOP

  LOAD_AS_DIRECTORY(X)
  <span class="number">1</span>. <span class="keyword">If</span> X/package.json is a file,
  a. Parse X/package.json, <span class="keyword">and</span> look <span class="keyword">for</span> <span class="string">"main"</span> field.
  b. let M = X + (json main field)
  c. LOAD_AS_FILE(M)
  <span class="number">2</span>. <span class="keyword">If</span> X/index.js is a file, load X/index.js <span class="keyword">as</span> JavaScript text.  STOP
  <span class="number">3</span>. <span class="keyword">If</span> X/index.json is a file, parse X/index.json to a JavaScript object. STOP

  LOAD_NODE_MODULES(X, START)
  <span class="number">1</span>. let DIRS=NODE_MODULES_PATHS(START)
  <span class="number">2</span>. <span class="keyword">for</span> each DIR in DIRS:
  a. LOAD_AS_FILE(DIR/X)
  b. LOAD_AS_DIRECTORY(DIR/X)

  NODE_MODULES_PATHS(START)
  <span class="number">1</span>. let PARTS = path split(START)
  <span class="number">2</span>. let I = count of PARTS - <span class="number">1</span>
  <span class="number">3</span>. let DIRS = []
  <span class="number">4</span>. <span class="keyword">while</span> I &gt;= <span class="number">0</span>,
  a. <span class="keyword">if</span> PARTS[I] = <span class="string">"node_modules"</span> <span class="keyword">CONTINUE</span>
  c. DIR = path join(PARTS[<span class="number">0</span> .. I] + <span class="string">"node_modules"</span>)
  b. DIRS = DIRS + DIR
  c. let I = I - <span class="number">1</span>
  <span class="number">5</span>. <span class="keyword">return</span> DIRS</pre></td></tr></tbody></table></figure></div>
  </template>
  <template name="c">
    3
  </template>
</body>

</html>
